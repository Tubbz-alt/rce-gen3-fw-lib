// ==============================================================
// File generated by AutoESL - High-Level Synthesis System (C, C++, SystemC)
// Version: 2012.1
// Copyright (C) 2012 Xilinx Inc. All rights reserved.
// 
// ==============================================================

`timescale 1ns/1ps
module SOBEL_CONTROL_if
#(parameter
    C_BASEADDR    =   32'h00000000,
    C_HIGHADDR    =   32'h0000ffff,
    C_ADDR_WIDTH  =   32,
    C_DATA_WIDTH  =   32
)(
    // axi4 slave signals
    input  wire                      ACLK,
    input  wire                      ARESETN,
    input  wire [C_ADDR_WIDTH-1:0]   AWADDR,
    input  wire                      AWVALID,
    output wire                      AWREADY,
    input  wire [C_DATA_WIDTH-1:0]   WDATA,
    input  wire [C_DATA_WIDTH/8-1:0] WSTRB,
    input  wire                      WVALID,
    output wire                      WREADY,
    output wire [1:0]                BRESP,
    output wire                      BVALID,
    input  wire                      BREADY,
    input  wire [C_ADDR_WIDTH-1:0]   ARADDR,
    input  wire                      ARVALID,
    output wire                      ARREADY,
    output wire [C_DATA_WIDTH-1:0]   RDATA,
    output wire [1:0]                RRESP,
    output wire                      RVALID,
    input  wire                      RREADY,
    // user signals
    output wire                      DOUT_ap_start,
    input  wire                      DIN_ap_done,
    input  wire                      DIN_ap_idle
);
//------------------------Parameter----------------------
// address bits
localparam
    ADDR_BITS = 4;

// read address map
localparam
    R_ap_done = 4'h4,
    R_ap_idle = 4'h8;

// write address map
localparam
    W_ap_start = 4'h0;

//------------------------Local signal-------------------
// read
wire                 ar_transfer;    // indicate a transfer on read address channel
wire                 r_transfer;     // indicate a transfer on read data channel
wire [ADDR_BITS-1:0] raddr;          // local read address
reg                  rdata_valid;    // rdata valid flag
reg  [31:0]          rdata;          // read data buffer
// write
wire                 aw_transfer;    // indicate a transfer on write address channel
wire                 w_transfer;     // indicate a transfer on write data channel
wire                 b_transfer;     // indicate a transfer on write response channel
reg                  waddr_valid;    // waddr/wmask valid flag
reg  [ADDR_BITS-1:0] waddr;          // local write address buffer
reg  [31:0]          wmask;          // write mask buffer
reg                  wdata_valid;    // wdata valid flag
reg  [31:0]          wdata;          // write data buffer
// internal
reg                  sig_ap_start;
wire                 sig_ap_done;
wire                 sig_ap_idle;
//------------------------Body---------------------------
//++++++++++++++++++++++++read+++++++++++++++++++++++++++
assign  ARREADY =   ~rdata_valid | r_transfer;
assign  RDATA   =   rdata;
assign  RRESP   =   2'b00;  // OKAY
assign  RVALID  =   rdata_valid;

assign  ar_transfer =   ARVALID & ARREADY;
assign  r_transfer  =   RVALID & RREADY;
assign  raddr       =   ARADDR[ADDR_BITS-1:0];

// rdata_valid
always @(posedge ACLK) begin
    if (~ARESETN)
        rdata_valid <=  1'b0;
    else if (ar_transfer)
        rdata_valid <=  1'b1;
    else if (r_transfer)
        rdata_valid <=  1'b0;
end

// rdata
always @(posedge ACLK) begin
    if (~ARESETN)
        rdata   <=  1'b0;
    else if (ar_transfer) begin
        case (raddr)
            R_ap_done : rdata <= sig_ap_done;
            R_ap_idle : rdata <= sig_ap_idle;
            default   : rdata <= 1'b0;
        endcase
    end
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++write++++++++++++++++++++++++++
assign  AWREADY =   ~waddr_valid | b_transfer;
assign  WREADY  =   ~wdata_valid | b_transfer;
assign  BRESP   =   2'b00;  // OKAY
assign  BVALID  =   waddr_valid & wdata_valid;

assign  aw_transfer =   AWVALID & AWREADY;
assign  w_transfer  =   WVALID & WREADY;
assign  b_transfer  =   BVALID & BREADY;

// waddr_valid
always @(posedge ACLK) begin
    if (~ARESETN)
        waddr_valid <=  1'b0;
    else if (aw_transfer)
        waddr_valid <=  1'b1;
    else if (b_transfer)
        waddr_valid <=  1'b0;
end

// wdata_valid
always @(posedge ACLK) begin
    if (~ARESETN)
        wdata_valid <=  1'b0;
    else if (w_transfer)
        wdata_valid <=  1'b1;
    else if (b_transfer)
        wdata_valid <=  1'b0;
end

// waddr
always @(posedge ACLK) begin
    if (~ARESETN)
        waddr   <=  1'b0;
    else if (w_transfer)
        waddr   <=  AWADDR[ADDR_BITS-1:0];
end

// wmask
always @(posedge ACLK) begin
    if (~ARESETN)
        wmask   <=  1'b0;
    else if (w_transfer)
        wmask   <=  {{8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}}};
end

// wdata
always @(posedge ACLK) begin
    if (~ARESETN)
        wdata   <=  1'b0;
    else if (w_transfer)
        wdata   <=  WDATA;
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++internal+++++++++++++++++++++++
assign DOUT_ap_start = sig_ap_start;

assign sig_ap_done   = DIN_ap_done;
assign sig_ap_idle   = DIN_ap_idle;

// input control
always @(posedge ACLK) begin
    if (~ARESETN)
        sig_ap_start <= 1'b0;
    else if (b_transfer && waddr == W_ap_start && wmask[0] && wdata[0])
        sig_ap_start <= 1'b1;
    else
        sig_ap_start <= 1'b0;
end

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

endmodule
