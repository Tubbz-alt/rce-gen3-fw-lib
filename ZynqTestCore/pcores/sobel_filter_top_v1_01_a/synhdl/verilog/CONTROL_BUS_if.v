// ==============================================================
// File generated by AutoESL - High-Level Synthesis System (C, C++, SystemC)
// Version: 2012.1
// Copyright (C) 2012 Xilinx Inc. All rights reserved.
// 
// ==============================================================

`timescale 1ns/1ps
module CONTROL_BUS_if
#(parameter
    C_BASEADDR    =   32'h00000000,
    C_HIGHADDR    =   32'h0000ffff,
    C_ADDR_WIDTH  =   32,
    C_DATA_WIDTH  =   32
)(
    // axi4 slave signals
    input  wire                      ACLK,
    input  wire                      ARESETN,
    input  wire [C_ADDR_WIDTH-1:0]   AWADDR,
    input  wire                      AWVALID,
    output wire                      AWREADY,
    input  wire [C_DATA_WIDTH-1:0]   WDATA,
    input  wire [C_DATA_WIDTH/8-1:0] WSTRB,
    input  wire                      WVALID,
    output wire                      WREADY,
    output wire [1:0]                BRESP,
    output wire                      BVALID,
    input  wire                      BREADY,
    input  wire [C_ADDR_WIDTH-1:0]   ARADDR,
    input  wire                      ARVALID,
    output wire                      ARREADY,
    output wire [C_DATA_WIDTH-1:0]   RDATA,
    output wire [1:0]                RRESP,
    output wire                      RVALID,
    input  wire                      RREADY,
    // user signals
    output wire [31:0]               DOUT_rows,
    output wire [31:0]               DOUT_cols
);
//------------------------Parameter----------------------
// address bits
localparam
    ADDR_BITS = 3;

// read address map
localparam
    R_rows_0 = 3'h0,
    R_cols_0 = 3'h4;

// write address map
localparam
    W_rows_0 = 3'h0,
    W_cols_0 = 3'h4;

//------------------------Local signal-------------------
// read
wire                 ar_transfer;    // indicate a transfer on read address channel
wire                 r_transfer;     // indicate a transfer on read data channel
wire [ADDR_BITS-1:0] raddr;          // local read address
reg                  rdata_valid;    // rdata valid flag
reg  [31:0]          rdata;          // read data buffer
// write
wire                 aw_transfer;    // indicate a transfer on write address channel
wire                 w_transfer;     // indicate a transfer on write data channel
wire                 b_transfer;     // indicate a transfer on write response channel
reg                  waddr_valid;    // waddr/wmask valid flag
reg  [ADDR_BITS-1:0] waddr;          // local write address buffer
reg  [31:0]          wmask;          // write mask buffer
reg                  wdata_valid;    // wdata valid flag
reg  [31:0]          wdata;          // write data buffer
// internal
reg  [31:0]          sig_rows;
reg  [31:0]          sig_cols;
//------------------------Body---------------------------
//++++++++++++++++++++++++read+++++++++++++++++++++++++++
assign  ARREADY =   ~rdata_valid | r_transfer;
assign  RDATA   =   rdata;
assign  RRESP   =   2'b00;  // OKAY
assign  RVALID  =   rdata_valid;

assign  ar_transfer =   ARVALID & ARREADY;
assign  r_transfer  =   RVALID & RREADY;
assign  raddr       =   ARADDR[ADDR_BITS-1:0];

// rdata_valid
always @(posedge ACLK) begin
    if (~ARESETN)
        rdata_valid <=  1'b0;
    else if (ar_transfer)
        rdata_valid <=  1'b1;
    else if (r_transfer)
        rdata_valid <=  1'b0;
end

// rdata
always @(posedge ACLK) begin
    if (~ARESETN)
        rdata   <=  1'b0;
    else if (ar_transfer) begin
        case (raddr)
            R_rows_0 : rdata <= sig_rows[31:0];
            R_cols_0 : rdata <= sig_cols[31:0];
            default  : rdata <= 1'b0;
        endcase
    end
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++write++++++++++++++++++++++++++
assign  AWREADY =   ~waddr_valid | b_transfer;
assign  WREADY  =   ~wdata_valid | b_transfer;
assign  BRESP   =   2'b00;  // OKAY
assign  BVALID  =   waddr_valid & wdata_valid;

assign  aw_transfer =   AWVALID & AWREADY;
assign  w_transfer  =   WVALID & WREADY;
assign  b_transfer  =   BVALID & BREADY;

// waddr_valid
always @(posedge ACLK) begin
    if (~ARESETN)
        waddr_valid <=  1'b0;
    else if (aw_transfer)
        waddr_valid <=  1'b1;
    else if (b_transfer)
        waddr_valid <=  1'b0;
end

// wdata_valid
always @(posedge ACLK) begin
    if (~ARESETN)
        wdata_valid <=  1'b0;
    else if (w_transfer)
        wdata_valid <=  1'b1;
    else if (b_transfer)
        wdata_valid <=  1'b0;
end

// waddr
always @(posedge ACLK) begin
    if (~ARESETN)
        waddr   <=  1'b0;
    else if (w_transfer)
        waddr   <=  AWADDR[ADDR_BITS-1:0];
end

// wmask
always @(posedge ACLK) begin
    if (~ARESETN)
        wmask   <=  1'b0;
    else if (w_transfer)
        wmask   <=  {{8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}}};
end

// wdata
always @(posedge ACLK) begin
    if (~ARESETN)
        wdata   <=  1'b0;
    else if (w_transfer)
        wdata   <=  WDATA;
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++internal+++++++++++++++++++++++
assign DOUT_rows = sig_rows;
assign DOUT_cols = sig_cols;


// input data
always @(posedge ACLK) begin
    if (~ARESETN) begin
        sig_rows <= 1'b0;
        sig_cols <= 1'b0;
    end
    else if (b_transfer) begin
        case (waddr)
            W_rows_0 : sig_rows[31:0] <= (wdata[31:0] & wmask) | (sig_rows[31:0] & ~wmask);
            W_cols_0 : sig_cols[31:0] <= (wdata[31:0] & wmask) | (sig_cols[31:0] & ~wmask);
        endcase
    end
end

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

endmodule
