// ==============================================================
// File generated by AutoESL - High-Level Synthesis System (C, C++, SystemC)
// Version: 2012.1
// Copyright (C) 2012 Xilinx Inc. All rights reserved.
// 
// ==============================================================


`timescale 1ns/1ps

module INPUT_STREAM_if (
    // system singals
    input  wire        clk,
    input  wire        reset,
    // AXI4-Stream singals
    input  wire        TVALID,
    output wire        TREADY,
    input  wire [23:0] TDATA,
    input  wire [2:0]  TSTRB,
    input  wire [0:0]  TUSER,
    input  wire [0:0]  TLAST,
    input  wire [0:0]  TDEST,
    // User signals
    output wire [23:0] inter_pix_data_V_dout,
    output wire        inter_pix_data_V_empty_n,
    input  wire        inter_pix_data_V_read,
    output wire [2:0]  inter_pix_strb_V_dout,
    output wire        inter_pix_strb_V_empty_n,
    input  wire        inter_pix_strb_V_read,
    output wire [0:0]  inter_pix_user_V_dout,
    output wire        inter_pix_user_V_empty_n,
    input  wire        inter_pix_user_V_read,
    output wire [0:0]  inter_pix_last_V_dout,
    output wire        inter_pix_last_V_empty_n,
    input  wire        inter_pix_last_V_read,
    output wire [0:0]  inter_pix_tdest_V_dout,
    output wire        inter_pix_tdest_V_empty_n,
    input  wire        inter_pix_tdest_V_read
);
//------------------------Local signal-------------------
// AXI4-Stream
wire        transfer;
reg         valid;
reg  [23:0] TDATA_buf;
reg  [2:0]  TSTRB_buf;
reg         TUSER_buf;
reg         TLAST_buf;
reg         TDEST_buf;
// FIFO
wire        fifo_write;
wire        fifo_full_n;
wire        inter_pix_data_V_full_n;
wire        inter_pix_strb_V_full_n;
wire        inter_pix_user_V_full_n;
wire        inter_pix_last_V_full_n;
wire        inter_pix_tdest_V_full_n;

//------------------------Instantiation------------------
// inter_pix_data_V_fifo
INPUT_STREAM_fifo #(
    .DATA_BITS  ( 24 ),
    .DEPTH_BITS ( 4 )
) inter_pix_data_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( inter_pix_data_V_empty_n ),
    .full_n     ( inter_pix_data_V_full_n ),
    .read       ( inter_pix_data_V_read ),
    .write      ( fifo_write ),
    .dout       ( inter_pix_data_V_dout ),
    .din        ( TDATA_buf )
);

// inter_pix_strb_V_fifo
INPUT_STREAM_fifo #(
    .DATA_BITS  ( 3 ),
    .DEPTH_BITS ( 4 )
) inter_pix_strb_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( inter_pix_strb_V_empty_n ),
    .full_n     ( inter_pix_strb_V_full_n ),
    .read       ( inter_pix_strb_V_read ),
    .write      ( fifo_write ),
    .dout       ( inter_pix_strb_V_dout ),
    .din        ( TSTRB_buf )
);

// inter_pix_user_V_fifo
INPUT_STREAM_fifo #(
    .DATA_BITS  ( 1 ),
    .DEPTH_BITS ( 4 )
) inter_pix_user_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( inter_pix_user_V_empty_n ),
    .full_n     ( inter_pix_user_V_full_n ),
    .read       ( inter_pix_user_V_read ),
    .write      ( fifo_write ),
    .dout       ( inter_pix_user_V_dout ),
    .din        ( TUSER_buf )
);

// inter_pix_last_V_fifo
INPUT_STREAM_fifo #(
    .DATA_BITS  ( 1 ),
    .DEPTH_BITS ( 4 )
) inter_pix_last_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( inter_pix_last_V_empty_n ),
    .full_n     ( inter_pix_last_V_full_n ),
    .read       ( inter_pix_last_V_read ),
    .write      ( fifo_write ),
    .dout       ( inter_pix_last_V_dout ),
    .din        ( TLAST_buf )
);

// inter_pix_tdest_V_fifo
INPUT_STREAM_fifo #(
    .DATA_BITS  ( 1 ),
    .DEPTH_BITS ( 4 )
) inter_pix_tdest_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( inter_pix_tdest_V_empty_n ),
    .full_n     ( inter_pix_tdest_V_full_n ),
    .read       ( inter_pix_tdest_V_read ),
    .write      ( fifo_write ),
    .dout       ( inter_pix_tdest_V_dout ),
    .din        ( TDEST_buf )
);

//------------------------Body---------------------------
//++++++++++++++++++++++++AXI4-Stream++++++++++++++++++++
assign TREADY   = ~valid | fifo_write;
assign transfer = TVALID & TREADY;

// valid
always @(posedge clk) begin
    if (reset)
        valid <= 1'b0;
    else if (transfer)
        valid <= 1'b1;
    else if (fifo_write)
        valid <= 1'b0;
end

// TDATA_buf
always @(posedge clk) begin
    if (reset)
        TDATA_buf <= 1'b0;
    else if (transfer)
        TDATA_buf <= TDATA;
end

// TSTRB_buf
always @(posedge clk) begin
    if (reset)
        TSTRB_buf <= 1'b0;
    else if (transfer)
        TSTRB_buf <= TSTRB;
end

// TUSER_buf
always @(posedge clk) begin
    if (reset)
        TUSER_buf <= 1'b0;
    else if (transfer)
        TUSER_buf <= TUSER;
end

// TLAST_buf
always @(posedge clk) begin
    if (reset)
        TLAST_buf <= 1'b0;
    else if (transfer)
        TLAST_buf <= TLAST;
end

// TDEST_buf
always @(posedge clk) begin
    if (reset)
        TDEST_buf <= 1'b0;
    else if (transfer)
        TDEST_buf <= TDEST;
end

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++FIFO+++++++++++++++++++++++++++
assign fifo_write  = fifo_full_n & valid;
assign fifo_full_n = inter_pix_data_V_full_n & inter_pix_strb_V_full_n & inter_pix_user_V_full_n & inter_pix_last_V_full_n & inter_pix_tdest_V_full_n;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

endmodule



`timescale 1ns/1ps

module INPUT_STREAM_fifo
#(parameter
    DATA_BITS  = 8,
    DEPTH_BITS = 4
)(
    input  wire                 clk,
    input  wire                 aclr,
    output wire                 empty_n,
    output wire                 full_n,
    input  wire                 read,
    input  wire                 write,
    output wire [DATA_BITS-1:0] dout,
    input  wire [DATA_BITS-1:0] din
);
//------------------------Parameter----------------------
localparam
    DEPTH = 1 << DEPTH_BITS;
//------------------------Local signal-------------------
reg                   empty;
reg                   full;
reg  [DEPTH_BITS-1:0] index;
reg  [DATA_BITS-1:0]  mem[0:DEPTH-1];
//------------------------Body---------------------------
assign empty_n = ~empty;
assign full_n  = ~full;
assign dout    = mem[index];

// empty
always @(posedge clk or posedge aclr) begin
    if (aclr)
        empty <= 1'b1;
    else if (empty & write & ~read)
        empty <= 1'b0;
    else if (~empty & ~write & read & (index==1'b0))
        empty <= 1'b1;
end

// full
always @(posedge clk or posedge aclr) begin
    if (aclr)
        full <= 1'b0;
    else if (full & read & ~write)
        full <= 1'b0;
    else if (~full & ~read & write & (index==DEPTH-2'd2))
        full <= 1'b1;
end

// index
always @(posedge clk or posedge aclr) begin
    if (aclr)
        index <= {DEPTH_BITS{1'b1}};
    else if (~empty & ~write & read)
        index <= index - 1'b1;
    else if (~full & ~read & write)
        index <= index + 1'b1;
end

// mem
always @(posedge clk) begin
    if (~full & write) mem[0] <= din;
end

genvar i;
generate
    for (i = 1; i < DEPTH; i = i + 1) begin : gen_sr
        always @(posedge clk) begin
            if (~full & write) mem[i] <= mem[i-1];
        end
    end
endgenerate

endmodule
