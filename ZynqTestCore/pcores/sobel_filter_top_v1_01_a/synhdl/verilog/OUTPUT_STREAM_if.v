// ==============================================================
// File generated by AutoESL - High-Level Synthesis System (C, C++, SystemC)
// Version: 2012.1
// Copyright (C) 2012 Xilinx Inc. All rights reserved.
// 
// ==============================================================


`timescale 1ns/1ps

module OUTPUT_STREAM_if (
    // system singals
    input  wire        clk,
    input  wire        reset,
    // AXI4-Stream singals
    output wire        TVALID,
    input  wire        TREADY,
    output wire [23:0] TDATA,
    output wire [2:0]  TSTRB,
    output wire [0:0]  TUSER,
    output wire [0:0]  TLAST,
    output wire [0:0]  TDEST,
    // User signals
    input  wire [23:0] out_pix_data_V_din,
    output wire        out_pix_data_V_full_n,
    input  wire        out_pix_data_V_write,
    input  wire [2:0]  out_pix_strb_V_din,
    output wire        out_pix_strb_V_full_n,
    input  wire        out_pix_strb_V_write,
    input  wire [0:0]  out_pix_user_V_din,
    output wire        out_pix_user_V_full_n,
    input  wire        out_pix_user_V_write,
    input  wire [0:0]  out_pix_last_V_din,
    output wire        out_pix_last_V_full_n,
    input  wire        out_pix_last_V_write,
    input  wire [0:0]  out_pix_tdest_V_din,
    output wire        out_pix_tdest_V_full_n,
    input  wire        out_pix_tdest_V_write
);
//------------------------Local signal-------------------
// AXI4-Stream
wire        transfer;
reg         valid;
reg  [23:0] TDATA_buf;
reg  [2:0]  TSTRB_buf;
reg         TUSER_buf;
reg         TLAST_buf;
reg         TDEST_buf;
// FIFO
wire        fifo_read;
wire        fifo_empty_n;
wire [23:0] out_pix_data_V_dout;
wire        out_pix_data_V_empty_n;
wire [2:0]  out_pix_strb_V_dout;
wire        out_pix_strb_V_empty_n;
wire        out_pix_user_V_dout;
wire        out_pix_user_V_empty_n;
wire        out_pix_last_V_dout;
wire        out_pix_last_V_empty_n;
wire        out_pix_tdest_V_dout;
wire        out_pix_tdest_V_empty_n;

//------------------------Instantiation------------------
// out_pix_data_V_fifo
OUTPUT_STREAM_fifo #(
    .DATA_BITS  ( 24 ),
    .DEPTH_BITS ( 4 )
) out_pix_data_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( out_pix_data_V_empty_n ),
    .full_n     ( out_pix_data_V_full_n ),
    .read       ( fifo_read ),
    .write      ( out_pix_data_V_write ),
    .dout       ( out_pix_data_V_dout ),
    .din        ( out_pix_data_V_din )
);

// out_pix_strb_V_fifo
OUTPUT_STREAM_fifo #(
    .DATA_BITS  ( 3 ),
    .DEPTH_BITS ( 4 )
) out_pix_strb_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( out_pix_strb_V_empty_n ),
    .full_n     ( out_pix_strb_V_full_n ),
    .read       ( fifo_read ),
    .write      ( out_pix_strb_V_write ),
    .dout       ( out_pix_strb_V_dout ),
    .din        ( out_pix_strb_V_din )
);

// out_pix_user_V_fifo
OUTPUT_STREAM_fifo #(
    .DATA_BITS  ( 1 ),
    .DEPTH_BITS ( 4 )
) out_pix_user_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( out_pix_user_V_empty_n ),
    .full_n     ( out_pix_user_V_full_n ),
    .read       ( fifo_read ),
    .write      ( out_pix_user_V_write ),
    .dout       ( out_pix_user_V_dout ),
    .din        ( out_pix_user_V_din )
);

// out_pix_last_V_fifo
OUTPUT_STREAM_fifo #(
    .DATA_BITS  ( 1 ),
    .DEPTH_BITS ( 4 )
) out_pix_last_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( out_pix_last_V_empty_n ),
    .full_n     ( out_pix_last_V_full_n ),
    .read       ( fifo_read ),
    .write      ( out_pix_last_V_write ),
    .dout       ( out_pix_last_V_dout ),
    .din        ( out_pix_last_V_din )
);

// out_pix_tdest_V_fifo
OUTPUT_STREAM_fifo #(
    .DATA_BITS  ( 1 ),
    .DEPTH_BITS ( 4 )
) out_pix_tdest_V_fifo (
    .clk        ( clk ),
    .aclr       ( reset ),
    .empty_n    ( out_pix_tdest_V_empty_n ),
    .full_n     ( out_pix_tdest_V_full_n ),
    .read       ( fifo_read ),
    .write      ( out_pix_tdest_V_write ),
    .dout       ( out_pix_tdest_V_dout ),
    .din        ( out_pix_tdest_V_din )
);

//------------------------Body---------------------------
//++++++++++++++++++++++++AXI4-Stream++++++++++++++++++++
assign TVALID   = valid;
assign TDATA    = TDATA_buf;
assign TSTRB    = TSTRB_buf;
assign TUSER    = TUSER_buf;
assign TLAST    = TLAST_buf;
assign TDEST    = TDEST_buf;
assign transfer = TVALID & TREADY;

// valid
always @(posedge clk) begin
    if (reset)
        valid <= 1'b0;
    else if (fifo_read)
        valid <= 1'b1;
    else if (transfer)
        valid <= 1'b0;
end

// TDATA_buf
always @(posedge clk) begin
    if (reset)
        TDATA_buf <= 1'b0;
    else if (fifo_read)
        TDATA_buf <= out_pix_data_V_dout;
end

// TSTRB_buf
always @(posedge clk) begin
    if (reset)
        TSTRB_buf <= 1'b0;
    else if (fifo_read)
        TSTRB_buf <= out_pix_strb_V_dout;
end

// TUSER_buf
always @(posedge clk) begin
    if (reset)
        TUSER_buf <= 1'b0;
    else if (fifo_read)
        TUSER_buf <= out_pix_user_V_dout;
end

// TLAST_buf
always @(posedge clk) begin
    if (reset)
        TLAST_buf <= 1'b0;
    else if (fifo_read)
        TLAST_buf <= out_pix_last_V_dout;
end

// TDEST_buf
always @(posedge clk) begin
    if (reset)
        TDEST_buf <= 1'b0;
    else if (fifo_read)
        TDEST_buf <= out_pix_tdest_V_dout;
end

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++FIFO+++++++++++++++++++++++++++
assign fifo_read    = fifo_empty_n & (~valid | transfer);
assign fifo_empty_n = out_pix_data_V_empty_n & out_pix_strb_V_empty_n & out_pix_user_V_empty_n & out_pix_last_V_empty_n & out_pix_tdest_V_empty_n;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

endmodule



`timescale 1ns/1ps

module OUTPUT_STREAM_fifo
#(parameter
    DATA_BITS  = 8,
    DEPTH_BITS = 4
)(
    input  wire                 clk,
    input  wire                 aclr,
    output wire                 empty_n,
    output wire                 full_n,
    input  wire                 read,
    input  wire                 write,
    output wire [DATA_BITS-1:0] dout,
    input  wire [DATA_BITS-1:0] din
);
//------------------------Parameter----------------------
localparam
    DEPTH = 1 << DEPTH_BITS;
//------------------------Local signal-------------------
reg                   empty;
reg                   full;
reg  [DEPTH_BITS-1:0] index;
reg  [DATA_BITS-1:0]  mem[0:DEPTH-1];
//------------------------Body---------------------------
assign empty_n = ~empty;
assign full_n  = ~full;
assign dout    = mem[index];

// empty
always @(posedge clk or posedge aclr) begin
    if (aclr)
        empty <= 1'b1;
    else if (empty & write & ~read)
        empty <= 1'b0;
    else if (~empty & ~write & read & (index==1'b0))
        empty <= 1'b1;
end

// full
always @(posedge clk or posedge aclr) begin
    if (aclr)
        full <= 1'b0;
    else if (full & read & ~write)
        full <= 1'b0;
    else if (~full & ~read & write & (index==DEPTH-2'd2))
        full <= 1'b1;
end

// index
always @(posedge clk or posedge aclr) begin
    if (aclr)
        index <= {DEPTH_BITS{1'b1}};
    else if (~empty & ~write & read)
        index <= index - 1'b1;
    else if (~full & ~read & write)
        index <= index + 1'b1;
end

// mem
always @(posedge clk) begin
    if (~full & write) mem[0] <= din;
end

genvar i;
generate
    for (i = 1; i < DEPTH; i = i + 1) begin : gen_sr
        always @(posedge clk) begin
            if (~full & write) mem[i] <= mem[i-1];
        end
    end
endgenerate

endmodule
